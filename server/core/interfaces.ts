/**
 * Core Provider Interfaces for Tibetan Translation Tool V2
 *
 * This file defines the fundamental abstractions that enable a plugin-based architecture.
 * All service implementations should adhere to these interfaces to ensure consistency,
 * testability, and extensibility.
 *
 * @module server/core/interfaces
 */

/**
 * Provider for generating text embeddings used in semantic similarity operations.
 *
 * Embeddings are vector representations of text that capture semantic meaning,
 * enabling operations like similarity search, example selection, and translation memory.
 *
 * @interface EmbeddingProvider
 * @example
 * ```typescript
 * const provider = new GeminiEmbeddingProvider(apiKey, cache);
 *
 * // Get single embedding
 * const embedding = await provider.getEmbedding("བཀྲ་ཤིས་བདེ་ལེགས།");
 * console.log(embedding.length); // 768
 *
 * // Batch processing for efficiency
 * const texts = ["text1", "text2", "text3"];
 * const embeddings = await provider.getBatchEmbeddings(texts);
 * ```
 */
export interface EmbeddingProvider {
  /**
   * Generate embedding vector for a single text.
   *
   * The returned vector should always be of length `dimension`.
   * Results should be deterministic for the same input text.
   *
   * @param text - The text to embed (Tibetan, English, or mixed)
   * @returns Promise resolving to a normalized vector of floats
   * @throws {TranslationError} If API call fails or text is invalid
   */
  getEmbedding(text: string): Promise<number[]>;

  /**
   * Generate embeddings for multiple texts in a single batch operation.
   *
   * Batch processing is more efficient than individual calls due to:
   * - Reduced API overhead
   * - Better throughput
   * - Lower latency per item
   *
   * @param texts - Array of texts to embed
   * @returns Promise resolving to array of embeddings (same order as input)
   * @throws {TranslationError} If batch operation fails
   */
  getBatchEmbeddings(texts: string[]): Promise<number[][]>;

  /**
   * The dimensionality of embeddings produced by this provider.
   *
   * Common values:
   * - 768: Gemini, BERT-base
   * - 1536: OpenAI text-embedding-ada-002
   * - 384: Sentence-BERT small models
   *
   * @readonly
   */
  readonly dimension: number;
}

/**
 * Provider for AI-powered translation of Tibetan text to English.
 *
 * Translation providers wrap different AI models (Gemini, OpenAI, Anthropic)
 * and provide a consistent interface for the translation service.
 *
 * @interface TranslationProvider
 * @example
 * ```typescript
 * const provider = new GeminiTranslationProvider(apiKey, config);
 *
 * // Single translation
 * const result = await provider.translate(
 *   "བཀྲ་ཤིས་བདེ་ལེགས།",
 *   "Translate this Tibetan text to English..."
 * );
 *
 * // Batch translation for parallel processing
 * const chunks = ["chunk1", "chunk2", "chunk3"];
 * const results = await provider.translateBatch(chunks, prompt);
 * ```
 */
export interface TranslationProvider {
  /**
   * Translate a single text using the provided prompt.
   *
   * The prompt should contain instructions, examples, and context
   * generated by the PromptGenerator service.
   *
   * @param text - The Tibetan text to translate
   * @param prompt - The complete prompt including instructions and context
   * @returns Promise resolving to translation result with metadata
   * @throws {TranslationError} If translation fails or API quota exceeded
   */
  translate(text: string, prompt: string): Promise<TranslationResult>;

  /**
   * Translate multiple texts in batch using the same prompt.
   *
   * Implementations should:
   * - Process items in parallel where possible
   * - Respect rate limits
   * - Handle partial failures gracefully
   * - Return results in the same order as input
   *
   * @param texts - Array of Tibetan texts to translate
   * @param prompt - The prompt to use for all translations
   * @returns Promise resolving to array of translation results
   * @throws {TranslationError} If batch operation fails completely
   */
  translateBatch(texts: string[], prompt: string): Promise<TranslationResult[]>;

  /**
   * Whether this provider supports streaming responses.
   *
   * Streaming enables:
   * - Real-time UI updates
   * - Better UX for long translations
   * - Lower perceived latency
   *
   * @readonly
   */
  readonly supportsStreaming: boolean;

  /**
   * Optional: Stream a translation with progressive results.
   *
   * Only required if `supportsStreaming` is true.
   *
   * @param text - The text to translate
   * @param prompt - The prompt to use
   * @param onChunk - Callback fired for each chunk of the response
   * @returns Promise resolving when stream completes
   */
  translateStream?(
    text: string,
    prompt: string,
    onChunk: (chunk: string) => void
  ): Promise<TranslationResult>;
}

/**
 * Generic cache provider for key-value storage with TTL support.
 *
 * Cache providers enable multi-layer caching strategy:
 * - L1: In-memory (MemoryCache) - fastest, limited size
 * - L2: Redis (RedisCache) - fast, shared across instances
 * - L3: Database (DatabaseCache) - persistent, slower
 *
 * @interface CacheProvider
 * @example
 * ```typescript
 * const cache = new MemoryCache(1000); // Max 1000 items
 *
 * // Store with TTL
 * await cache.set('translation:abc123', result, 3600); // 1 hour
 *
 * // Retrieve
 * const cached = await cache.get<TranslationResult>('translation:abc123');
 *
 * // Clean up
 * await cache.delete('translation:abc123');
 * await cache.clear(); // Clear all
 * ```
 */
export interface CacheProvider {
  /**
   * Retrieve a value from the cache.
   *
   * @param key - The cache key
   * @returns Promise resolving to the cached value, or null if not found/expired
   */
  get<T>(key: string): Promise<T | null>;

  /**
   * Store a value in the cache with optional TTL.
   *
   * @param key - The cache key
   * @param value - The value to store (will be JSON serialized)
   * @param ttl - Time to live in seconds (optional, may have provider default)
   * @returns Promise resolving when storage is complete
   */
  set<T>(key: string, value: T, ttl?: number): Promise<void>;

  /**
   * Remove a specific key from the cache.
   *
   * @param key - The cache key to remove
   * @returns Promise resolving when deletion is complete
   */
  delete(key: string): Promise<void>;

  /**
   * Clear all entries from the cache.
   *
   * Use with caution - this affects all cached data.
   *
   * @returns Promise resolving when cache is cleared
   */
  clear(): Promise<void>;

  /**
   * Optional: Check if a key exists in the cache.
   *
   * @param key - The cache key to check
   * @returns Promise resolving to true if key exists and hasn't expired
   */
  has?(key: string): Promise<boolean>;

  /**
   * Optional: Get multiple values in a single operation.
   *
   * More efficient than multiple `get()` calls for providers that support it.
   *
   * @param keys - Array of cache keys
   * @returns Promise resolving to array of values (null for missing keys)
   */
  mget?<T>(keys: string[]): Promise<(T | null)[]>;

  /**
   * Optional: Set multiple values in a single operation.
   *
   * @param entries - Array of key-value-ttl tuples
   * @returns Promise resolving when all values are stored
   */
  mset?<T>(entries: Array<[string, T, number?]>): Promise<void>;
}

/**
 * Generic storage provider for persisting structured data.
 *
 * Storage providers abstract the underlying persistence mechanism
 * (PostgreSQL, SQLite, MongoDB, etc.) and provide a unified interface
 * for saving and querying domain objects.
 *
 * @interface StorageProvider
 * @example
 * ```typescript
 * const storage = new PostgresStorageProvider(dbConfig);
 *
 * // Save a translation
 * const id = await storage.save('translations', {
 *   sourceText: "བཀྲ་ཤིས་བདེ་ལེགས།",
 *   translation: "Greetings (བཀྲ་ཤིས་བདེ་ལེགས།).",
 *   confidence: 0.95
 * });
 *
 * // Load by ID
 * const translation = await storage.load('translations', id);
 *
 * // Query with filters
 * const recent = await storage.query('translations', {
 *   where: { confidence: { gte: 0.8 } },
 *   orderBy: { createdAt: 'desc' },
 *   limit: 10
 * });
 * ```
 */
export interface StorageProvider {
  /**
   * Save a document to a collection.
   *
   * If the document has an `id` field, it will be used as the primary key.
   * Otherwise, a new ID will be generated.
   *
   * @param collection - The collection/table name
   * @param data - The document to save
   * @returns Promise resolving to the document's ID
   * @throws {StorageError} If save operation fails
   */
  save(collection: string, data: any): Promise<string>;

  /**
   * Load a document by ID.
   *
   * @param collection - The collection/table name
   * @param id - The document ID
   * @returns Promise resolving to the document, or null if not found
   * @throws {StorageError} If load operation fails
   */
  load(collection: string, id: string): Promise<any | null>;

  /**
   * Query documents with filters, sorting, and pagination.
   *
   * The filter object syntax should support common operations:
   * - Equality: { field: value }
   * - Comparison: { field: { gt: 5, lte: 10 } }
   * - Arrays: { field: { in: [1, 2, 3] } }
   * - Text: { field: { contains: 'search' } }
   *
   * @param collection - The collection/table name
   * @param filter - Query filter object
   * @returns Promise resolving to array of matching documents
   * @throws {StorageError} If query fails
   */
  query(collection: string, filter: any): Promise<any[]>;

  /**
   * Optional: Delete a document by ID.
   *
   * @param collection - The collection/table name
   * @param id - The document ID to delete
   * @returns Promise resolving to true if deleted, false if not found
   */
  delete?(collection: string, id: string): Promise<boolean>;

  /**
   * Optional: Update a document.
   *
   * @param collection - The collection/table name
   * @param id - The document ID
   * @param updates - Partial document with fields to update
   * @returns Promise resolving to the updated document
   */
  update?(collection: string, id: string, updates: any): Promise<any>;

  /**
   * Optional: Execute a transaction.
   *
   * Ensures atomicity for multiple operations.
   *
   * @param fn - Function containing operations to execute atomically
   * @returns Promise resolving to the function's return value
   */
  transaction?<T>(fn: (tx: StorageProvider) => Promise<T>): Promise<T>;
}

/**
 * Result type returned by translation providers.
 *
 * This is referenced by the TranslationProvider interface
 * but defined in shared/types.ts to be accessible from both
 * client and server code.
 */
export type { TranslationResult } from '../../shared/types';
